# myTinyRPC
手写自制建议rpc框架 
第一版：简易版，只支持一个连接

v2.0更新：
相比于第一版一个服务只支持一个连接，现在实现了注册表的功能，这样一个服务可支持多个客户端连接
并且将注册和连接这两步操作解耦

v3.0更新：
本节我们会将传统的 BIO 方式传输换成效率更高的 NIO 方式，当然不会使用 Java 原生的 NIO，
而是采用更为简单的 Netty。本节还会实现一个通用的序列化接口，为多种序列化支持做准备，并且，本节还会自定义传输的协议。

v4.0更新
新增nacos服务注册中心并且实现了负载均衡，且新增两个工厂类：线程池工厂以及单例工厂

tag:说下该rpc框架最核心的逻辑：
最开始先有一个暴露在外部的接口，在当前项目中暴露在外的接口是HelloService

客户端：客户端的工作就是向服务端发送rpc请求，所以我们特意封装了RpcRequset和RpcResponse对象。
并且创建了RpcClient接口，里面有一个方法为sendRequest（）。但是由于我们在客户端这一侧没有具体的HelloService（）的实现类，
所以就没办法直接生成实例对象。所以我们使用的动态代理的方法去生成实例，于是就有了RpcClientProxy类，该类的主要功能就是实现
动态代理，然后让动态代理去调用sendRequest（）方法。同时我提供了RpcClient的两种实现类，一种是基于Socket的实现SocketClient，
另一种是基于Netty框架的实现，即NettyClient，这里详细说NettyClient，在NettyClient中我们设置了netty的一些基本实现的代码，
并且在管道中设置了编码器和解码器以及NettyClientHandler类，NettyClientHandler的功能就是将客户端收到的消息存到ChannelHandlerContext中。

服务端：服务端相比于客户端会更复杂一些，首先在服务端中有ServiceProvider和ServiceRegister两个类，ServiceProvider是将服务放进我们的注册表，
注册表上面记录了我们能够提供的服务，注册表使用了Set和Map两个数据结构。ServiceRegister类是将我们的服务注册进nacos注册服务中心里面。
并且在服务端我们定义了RpcServer接口以及对应的Socket实现和Netty框架实现，在NettyServer中，我们也进行了基本的netty实现的代码，
并且将向客户端写出返回结果的任务交给了NettyServerHandler类，在NettyServerHandler类中又把调用具体接口的任务交给了RpcquestHandler类，
RpcquestHandler类中有一个handler方法，就是负责调用客户端发来的请求中请求调用的函数，并将调用结果返回。

以上为该rpc框架的核心逻辑
